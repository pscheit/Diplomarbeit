\chapter{Fazit}

Der \IM ist immer eines der Probleme gewesen, das mich am meisten interessiert habt. Bevor ich den richtigen Namen des Problems wusste, welches ich hatte, als ich meine erste objektorientierte Applikation mit einer MySQL-Datenbank schrieb, wurde mir bewusst, dass dies ein sowohl praktisches also auch theoretisch interessantes Problem ist. Bei der Vorbereitung für diese Arbeit dachte ich zuerst, dass es ein Problem seit genügend Material über dieses Problem zu finden. Mittlerweile habe ich über 40 Papers und Veröffentlichungen gefunden, die sich genau mit diesem Thema befassen. Vor allem waren viele nicht unter dem Stichwort \IMfull zu finden. Es war dennoch schwer Publikationen zu finden, die das Offensichtliche weiter vertiefen. Viele Arbeiten stellten zwar die Probleme und eine eigene Lösung vor, aber wurden dabei nicht sehr spezifisch. Somit begann ich das Kapitel mit der Vertiefung über das \term{Object Loading} ohne eine passende Arbeit darüber gefunden zu haben. Ich implementierte die ersten zwei naiven Herangehensweisen und kam zu dem Ergebnis, dass die \term{Roundtrips} der Schlüssel für die Performanz beim Laden sind.\\
Ein paar Wochen später habe ich auf http://www.odbms.org/ dann das entscheidene Whitepaper \cite{Bernstein99context-basedprefetch} für dieses Kapitel gefunden. Zu meiner Beruhigung kamen Bernstein, Pal und Shutt zu demselben Ergebnis wie ich und entwickelten dabei noch die beste Idee für das \term{Prefetching} von Objekten, die ich bisher kannte. \\

\section{Gibt es eine perfekte Lösung?}
Alles in allem ist die eine richtige, korrekte und performante Lösung des \IMfull schwer zu bestimmen. Viele Systeme haben sich in der Praxis bewährt und werden von vielen Entwicklern benutzt. In den meisten Fällen, die ich in dieser Arbeit vorgestellt habe, ist es vor allem wichtig, dass der Programmierer der Applikation weiß, wie er seine \ORM-Lösung einzusetzen hat. Eine Kenntnis über das relationale Schema ist bedingt durch die Natur des Problemes immer nötig. Wenn -- wie von allen gewünscht -- die Applikation von der eigentlichen Datenbanklösung durch eine Abstraktionsebene getrennt wird, verliert man zu oft zu viel Performanz. Der Tradeoff findet zwischen zwei Parametern statt: Der Abstraktion und der Performanz. In diesem Falle ist die Abstraktion der Grad, wie sorgfältig die Prinzipien der objektorientierten Programmierung umgesetzt werden. Die Performanz lässt sich dadurch bewerten, dass man sie mit einer komplett relational programmierten Lösung oder einer komplett objektorientierten Lösung vergleicht \cite[Kap. 3]{comparative-study-orm-tools}. Viele Beispiele aus den Problemen des \IM haben genau diese genannten Tradeoff-Parameter:
\begin{itemize}
\item Benutzt man lieber horizontales Mapping (performanter bei tiefen Klassenhierarchien) oder vertikales Mapping (flexibler gegen Änderungen)
\item Schreibt man SQL Befehle als String eingebettet in der Programmiersprache (performanter), oder entwickelt man eine eigene Abfrage-Sprache (flexibel, einfacher) oder eine objektorientierte SQL API (flexibler, sauberer, fehlerunanfälliger)
\item Lässt man dem Entwickler den Einblick in die Struktur der Daten, hat dieser die Möglichkeiten seine Abfragen so zu formulieren, dass sie vom Datenbanksystem optimiert werden können. Implementiert man einen \term{Database Abstraction Layer} kann man zwar das unterliegende \DBMS jederzeit austauschen, aber man verschleiert die Sicht des Entwicklers auf die Stuktur der Daten.
\item Kapselt man die Datenverwaltung eines Objektes streng in den Methoden des Objektes selbst oder lässt man zu, dass andere Objekte Daten für andere Objekte laden dürfen, so dass Synergie Effekte genutzt werden können (\term{Prefetching} von Attributen beim \term{Object Loading}).
\end{itemize}
Die Frage die sich also stellt, wenn man sich für eine Lösung des \IM entscheiden will, ist: Wieviel Performanz will man dafür einbüßen, dass man agiler, flexibler und fehlerfreier an objektorientierten Anwendungen mit relationalen Datenbanken als Persistenzsystem arbeiten kann? Diese Frage ist nicht für jeden Anwender pauschal zu beantworten und somit wird es auch nie eine einzige, perfekte Lösung für den \IM geben.
