\chapter{Einführung}

In diesem Teil der Arbeit möchte ich \PSCORM (gesprochen: Pe-Skorm) vorstellen. \PSCORM steht für: \textbf{P}HP \textbf{S}mart \textbf{C}ompiling \textbf{O}bject-\textbf{r}elational \textbf{M}apper und bezeichnet das Framework, welches ich im Rahmen dieser Arbeit konzipiert habe. \\
Im ersten Teil wurde eine Vielzahl von existieren Frameworks vorgestellt. Ein paar davon habe ich detaillierter untersucht und festgestellt, dass es schon gute und konkrete Lösungen für den \IM gibt. Wie ist also eine Neuentwicklung eines Frameworks in PHP motiviert? Anders als bei Java und .NET ist die Anzahl der Lösungen für \ORM-Probleme in PHP eher klein. Es gibt nicht viele innovative Lösungen, die sich durchsetzen konnten. Vielmehr ist es so, dass größere Frameworks\footnote{Zend, Symphonie}, die nicht nur den \IM als Problem addressierten, eine eigene \ORM-Lösung mitlieferten. Die meisten Entwickler wählten zuerst ihr allgemeines Framework und danach die \ORM-Lösung. Viele der \ORM-Frameworks, die es bereits gab, hatten zwar einige gute Ideen, wurden aber nicht weiterentwickelt und stetig verbessert. \\
Systeme, die sich durchsetzen, sind entweder viel zu umfangreich oder zu unflexibel und unvollständig. Vorallem die Spezialisierung auf Webentwicklung mit PHP, ist in den meisten Frameworks nicht vorhanden. So ist z.~B. Doctrine stark an Hibernate angelehnt, welches ursprünglich für Java geschrieben wurde. Es leuchtet also ein, dass Doctrine nicht speziell und ausschließlich für PHP entwickelt wurde. \\
Auch wenn ich nicht den Anspruch habe \PSCORM als eine völlig Neue Idee zu bezeichnen \cite{propel}, habe ich versucht die besten Ideen der bestehenden Frameworks auf einen Nenner zu bringen. Darüber hinaus habe ich, den aktuellen Forschungsstand über den \IM in das Konzept für \PSCORM einfließen lassen.

\section{Aufbau dieses Teils}

Zuerst gehe ich auf die Besonderheiten von PHP in der Webentwicklung ein, die Umdenken beim Programmieren verlangen. Anders als in Programmiersprachen wie Java, die durch die Virtual Machine ausgeführt werden und vorher kompiliert wurden, gibt es in PHP keine vergleichbare Struktur. \\
Danach werden die Konzepte von \PSCORM, die aus den Analysen des ersten Teils entstanden sind, vorgestellt. Viele Konzepte wurden von bekannten Frameworks übernommen -- auf diese werde ich dann nicht detaillierter eingehen, da sie bereits im ersten Teil ausführlich behandelt wurden. Besonders die Programmierung von dynamischem Code wird immer wieder eine Rolle spielen. Dabei benutzt \PSCORM einen eigenen Codeerzeuger, um einen Compiler zu simulieren. Dieses Konzept stelle ich im Kapitel \ref{dynamischer-code} vor. \\
In den weiteren Kapiteln werden die Implikationen dieses Konzept auf die anderen schon bekannten Konzepte aus dem ersten Teil der Arbeit übertragen. Dabei wird oft mit den schon bekannten Frameworks (insbesondere Doctrine) verglichen. \\
Im letzten Kapitel werden die zwei Testfälle aus dem Kapitel \ref{object-loading} benutzt, um die Performanz von Doctrine, Kohana und \PSCORM zu vergleichen. Die Ergebnisse werden vorgestellt und analysiert. \\

\section{Besonderheiten von PHP} \label{besonderheiten-php}

Bei einer objektorientierten Applikation in PHP gibt es einige Besonderheiten, die man beachten muss. PHP ist Insbesondere eine Scriptsprache für Webanwendungen. Diese weisen eine Besonderheit in Bezug auf den flüchtigen Speicher auf: Wird eine Webseite aufgerufen, sendet der Browser des Clients einen \term{HTTP-Request} an den Server. Der Server löst den Request auf und gibt diesen an den Interpreter (in dem Falle PHP) weiter. Der Interpreter liefert die HTML-Ausgabe des Ergebnisses und der Request ist beendet. Danach sind alle Inforamtionen dieses Requests, die nicht persistent gemacht wurden, wieder verloren. Es gibt auch keine Daten, die zur Laufzeit in einem Arbeitsspeicher gehalten werden können und neu für den nächsten Request benutzt werden.\\
Was bedeutet das für die Programmierung in PHP? Alle Informationen, die man zur Ausführung der Applikation braucht, müssen bei jedem Request in den Speicher geladen werden. Das bedeutet, dass z.~B. Konfigurationsdateien jedes mal neu ausgelesen werden müssen, Datenbankverbindungen neu erstellt werden müssen, oft genutzte Klassen müssen neu instanziiert werden und alle Informationen müssen persistent gemacht werden. Es ist nicht möglich die Applikation einmal zu initialisieren und dabei kostenspielige Operationen auszuführen, die im weiteren Verlauf gespart werden können. In jedem Request werden alle Initialisierungen der Applikation wieder neu ausgeführt. \\
Zusätzlich muss der Zugriff auf eine Webapplikation leseoptimiert sein. Stellt man sich eine durchschnittliche Webseite vor, die von einem CMS\footnote{Content Management System} gepflegt wird, sieht man, dass der Anteil der Aktionen, die Daten persistent speichern, viel geringer ist als der Anteil der Aktionen, die Daten lesen. Hier zu ein kleines Beipsiel:\\
Ein Redakteur speichert eine neue Seite im CMS ab. Eine Seite hat z.~B. 200.000 Requests\footnote{Aufrufe der Webseite durch Sufer} pro Tag; Das bedeutet, dass die Seite einmal gepeichert (Schreibzugriff), aber 200.000 mal geladen wird (Lesezugriff). \\
Eine weitere Besonderheit ist: Eine PHP Applikation mit geringem Codeumfang und einfach gehaltenem Code läuft schneller als eine PHP Applikation mit großem Codeumfang, starker Abstraktion und vielen Klassen. Das liegt daran, dass der Interpreter bei jedem Request alle Klassen der Applikation neu parsen muss (Syntaxüberprüfung, Transformation, Optimierung, etc). Da PHP ursprünglich keine objektorientierte Sprache war, sind auch manche Funktionen eher für Arrays\footnote{Collection und Universaldatenstruktur in PHP} als für Objekte optimiert. \\
Wenn man also versucht ein Projekt für PHP zu optimieren, sollte man folgende Dinge berücksichtigen:
\begin{itemize}
\item Man sollte immer den Lesezugriff auf Daten auf Kosten der Performanz des Schreibvorgangs optimieren.
\item Die Applikation sollte sich so schnell wie möglich initialisieren können.
\item Die Applikation sollte versuchen in einem Request nur die wichtigsten Daten zur Ausführung des Programms in den Arbeitsspeicher zu laden.
\item Der Codeumfang sollte so gering wie möglich gehalten werden.
\item Der Code sollte einfach gehalten werden.
\end{itemize}
